# Context:
I'm developing a 911 Emergency System (in Spanish language) to recollect data using Symfony 7 with SQL server.
Also, Front Project uses Janus lib to handle calls. Production uses DNS and Virtual Machines that way sensitive data cannot be stolen.

## Nomenclature:
+ PreCarta - A simplify DataSheet that is filled in the first 2 mins of the call with critical info. After completion, the "Full Carta Form" is visible to complete any necesary details of the call
+ Carta - This is the "Full Carta Form" from the call.
+ Agente - User with Role either Operador or Despachador.
+ Operador - User that handles the incoming calls and processes Cartas.
+ Despachador - Handle Cartas created and call to "Resources", like patrol, ambulance, etc.
+ Supervisor - Checks if all Agents (Operador/Despachador) do not have any problems. Also, they watch Metrics to find any critical issue.


# Code Context:
Chech this logic for the Autosave of a Carta

### From Backend
#[Route('/sendCartaStage', methods: ['post'])]
public function sendCartaStage(
    CartaService $cartaService,
    Request $request,
    SerializerInterface $serializer,
    MySession $session,
    EntityManagerInterface $em
): JsonResponse {
    $data = json_decode($request->getContent(), true);

    if ($data === null) {
        return $this->json(['error' => 'Invalid JSON'], 400);
    }

    $carta = $em->getRepository(Carta::class)->find($data["id"]);
    $commentsRTResponse = PendingCartasService::commentsHaveChanged($carta, $data);
    $operador = $session->getOperador();
    $role = $operador->getRoleLoginData();
    $esDespachador = OperadorRoleService::isDespachador($role);
    $notifService = new CartaNotificacionService($em, $this->pushNotifications, $operador);

    $data['operador_id'] = $operador->getId();

    // Creates Carta
    /** @var Carta */
    $carta = $cartaService->createsCartaWithInitialTime($data, $esDespachador);

    // Check if comentarios from Carta has changed
    if ($commentsRTResponse->hasChanged) {
        // Send firebase notification, updating comments from Carta
        $notifService->commentsChanged($carta, $commentsRTResponse->commentsJSON);
    }

    return $this->json(NuevaCartaService::serializeCartaInProgress(
        $carta,
        $serializer
    ));
}

### From Front
import { IzCartaDTO } from "api/schemes/Carta.Schema";
import { useCartasUtils } from "contexts/Carta/CartasUtilsContext";
import { debounce, isEqual, update } from "lodash";
import { useContext, useEffect, useMemo, useRef, useState } from "react";
import { toast } from "react-toastify";
import { CartaFormContext } from "screens/Home/views/Carta/context/CartaForm.Context";
import { CartaTimeStages } from "enums";
import { sendCartaStage } from "api/services/Carta.REST";
import { AuthContext } from "contexts/AuthProvider";
import { SetAuthCase } from "contexts/Session/lib";
import { setIdsFromCartaInProgress } from "./lib/setIds";

type Prop = {
    // This is useful for "full-carta" stage, where we don't want to auto-save
    // Until complete Form is fully render and filled with previous data
    // Only then we want to auto-save
    preventSaving?: boolean
}
export const useAutoSaves = ({ preventSaving: _preventSaving }: Prop = {}) => {
    const [currentStage, setCurrentStage] = useState<CartaTimeStages | null>(null);
    const [cartaId, setCartaId] = useState<number | null>(null);
    const [savingInProgress, setSavingInProgress] = useState(false);
    const prevFormDataRef = useRef<IzCartaDTO | null>(null);
    const latestFormDataRef = useRef<IzCartaDTO>({} as IzCartaDTO);
    const [alreadyStoredWithId, setAlreadyStoredWithId] = useState(false);

    const { setformDataFull, setformData, formData, isFormBuildingMemo } = useContext(CartaFormContext);
    const { authStates, updateAuthState } = useContext(AuthContext);
    const {
        setUnfinishedCartaToLS,
        setStartTimerOnCarta,
        startTimerOnCarta,
        setOffsetSeconds,
        preventSaving: preventSavingUtils
    } = useCartasUtils();

    const prvevntSavinRef = useRef<boolean>(false);

    useEffect(() => {
        prvevntSavinRef.current = preventSavingUtils || Boolean(_preventSaving);
    }, [preventSavingUtils, _preventSaving]);
    const preventSaving = useMemo<boolean>(() => preventSavingUtils || Boolean(_preventSaving), [preventSavingUtils, _preventSaving]);
    // Create a ref to store AbortController
    const abortControllerRef = useRef<AbortController | null>(null);

    useEffect(() => {
        if (preventSaving && abortControllerRef.current) {
            console.log("Aborting previous save");
            abortControllerRef.current.abort();
        }
    }, [preventSaving]);

    // Utility to check if formData is empty or invalid
    const isFormDataValid = (data: IzCartaDTO): boolean => {
        return Object.keys(data).length > 0 && !!data.telefonoLlamada && data.telefonoLlamada.length > 2;
    };

    // Update latestFormDataRef whenever formData changes
    useEffect(() => {
        latestFormDataRef.current = formData;

        if (formData.id && !alreadyStoredWithId) {
            setAlreadyStoredWithId(true);
        }

    }, [formData]);

    // Function to send updates to the backend
    const sendToBackend = async (stage?: CartaTimeStages, force = false) => {

        if (prvevntSavinRef.current && !force) return console.log("Skipping backend save: preventSaving is true");

        const dataToSend = latestFormDataRef.current;

        if (!isFormDataValid(dataToSend)) {
            console.warn("Skipping backend save: formData is empty or invalid", dataToSend);
            return;
        }

        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
        }

        abortControllerRef.current = new AbortController();

        try {
            setSavingInProgress(true);

            let _dto = { ...dataToSend };
            if (stage) _dto.stage = stage;
            const response = await sendCartaStage(_dto, abortControllerRef.current.signal);

            // We only updates the ids from the response
            let updateRes: IzCartaDTO = { ..._dto };

            setOffsetSeconds(response.offsetSeconds);

            // Use StateAction to update formData without loosing data while User still typing
            setformData((prev) => {
                updateRes = setIdsFromCartaInProgress(response, prev);

                console.log("peventSaving", prvevntSavinRef.current, authStates.cartaInProgess?.id);

                if (!authStates.cartaInProgess && !prvevntSavinRef.current)
                    updateAuthState({
                        type: SetAuthCase.cartaInProgess,
                        payload: updateRes,
                    })

                return {
                    ...prev,
                    ...updateRes,
                };
            });

            if (stage) setCurrentStage(stage);
            if (updateRes.id && !cartaId) setCartaId(updateRes.id);

            if (!startTimerOnCarta) setStartTimerOnCarta(true);

            if (!alreadyStoredWithId)
                toast.success("Carta guardada exitosamente", { autoClose: 2000 });
        } catch (error: any) {
            console.error("Error sending to backend:", error);
            if ("ERR_CANCELED" === error.code) return;
            toast.error("Error al guardar la Carta. Intenta de nuevo.");
        } finally {
            setSavingInProgress(false);
            // if (!prvevntSavinRef.current) {
            //     updateAuthState({
            //         type: SetAuthCase.hasUnfinishedCarta,
            //         payload: true,
            //     })
            // }
        }
    };

    // Debounced auto-save function, memoized to ensure a single instance
    const debouncedAutoSave = useMemo(
        () =>
            debounce((formDataToSave: IzCartaDTO) => {
                if (!isFormDataValid(formDataToSave)) {
                    console.warn("Skipping debounced save: formData is empty or invalid", formDataToSave);
                    return;
                }
                if (!isEqual(prevFormDataRef.current, formDataToSave)) {
                    sendToBackend();
                    prevFormDataRef.current = { ...formDataToSave };
                }
            }, 1000),
        [preventSaving, alreadyStoredWithId]
    );

    // Auto-save when formData changes
    useEffect(() => {
        if (isFormBuildingMemo || savingInProgress || !isFormDataValid(formData)) {
            // console.log("Auto-save effect skipped:", {
            //     isFormBuilding: isFormBuildingMemo,
            //     savingInProgress,
            //     formData,
            //     isFormValid: isFormDataValid(formData)
            // });
            return;
        }

        // console.log("Checking condition:", {
        //     flag: currentStage && !isEqual(prevFormDataRef.current, formData),
        //     currentStage,
        //     formData: formData.comentarios,
        //     prevFormData: prevFormDataRef.current?.comentarios,
        //     isEqual: isEqual(prevFormDataRef.current, formData),
        // });

        if (currentStage && !isEqual(prevFormDataRef.current, formData)) {
            // Deep clone formData to ensure new references
            const clonedFormData = JSON.parse(JSON.stringify(formData));
            debouncedAutoSave(clonedFormData);
        }
    }, [formData, isFormBuildingMemo, currentStage, savingInProgress, debouncedAutoSave]);

    // Detect PreCarta start
    useEffect(() => {
        if (
            isFormBuildingMemo ||
            savingInProgress ||
            !formData.telefonoLlamada ||
            formData.telefonoLlamada.length < 3
        ) {
            console.log("PreCarta effect skipped:", {
                isFormBuilding: isFormBuildingMemo,
                savingInProgress,
                telefonoLlamada: formData.telefonoLlamada
            });

            return;
        }



        if (currentStage === null) {
            console.log("Checking condition:", { currentStage });
            sendToBackend(CartaTimeStages.pre_carta_start);
            prevFormDataRef.current = { ...formData };
        }

    }, [formData, isFormBuildingMemo, savingInProgress]);

    // Detect when FullCarta starts (ONLY HAPPENS AFTER PRE-CARTA IS DONE)
    useEffect(() => {

        if (!authStates.cartaInProgess || preventSaving) return

        if (authStates.cartaInProgess.stage === CartaTimeStages.carta_start) {
            console.log('authStates.cartaInProgess', authStates.cartaInProgess);


            setCurrentStage(CartaTimeStages.carta_start);
            setCartaId(authStates.cartaInProgess.id);
            setformDataFull(authStates.cartaInProgess);

            // Only set prevFormDataRef if it’s null, preserving previous state if any
            if (!prevFormDataRef.current) {
                prevFormDataRef.current = { ...authStates.cartaInProgess };
            }
        }
    }, [authStates.cartaInProgess, preventSaving])

    // Cleanup: Cancel debounced save on unmount
    useEffect(() => {
        return () => {
            debouncedAutoSave.cancel();
        };
    }, [debouncedAutoSave]);

    // Optional: Save to local storage as a fallback
    const saveTempForm = (form: IzCartaDTO) => {
        return setUnfinishedCartaToLS(form);
    };

    const clearStates = () => {
        prevFormDataRef.current = null;
    }


    useEffect(() => {
        return () => {
            clearStates();
        }

    }, [])

    return {
        currentStage,
        cartaId,
        savingInProgress,
        sendToBackend,
        isSaving: () => savingInProgress,
        updatePrevFormData: (form: IzCartaDTO) => {
            prevFormDataRef.current = { ...form };
        }
    };
};

---

# Question
Currently, there is a rare situation when the Carta is stored multiple times as "duplication", each Carta have the same phoneNumberCall, but with different id (is unique from SQL rules).

This only happens in production and not so often, every manual test we do it can never be replicated.

Anyway, I would like to focus on a way to prevent this from backend position.
I Imagine to check if User's latets Carta is at least 1 minute old to create a new one. So we can avoid the "duplicates" cartas.


